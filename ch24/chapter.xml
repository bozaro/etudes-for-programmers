<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="ch24" xml:lang="ru"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Секрет фирмы</title>

  <subtitle>или математический подход к раскрытию шифров</subtitle>

  <para>Представьте себе такую ситуацию. Благодаря выдающимся профессиональным
  познаниям и незаурядным программистским способностям вас выдвинули на
  должность руководителя большой группы сотрудников, занимающихся разработкой
  суперновейшего и пока еще секретного Мини-компилятора для ЭВМ УМ-1 (см.
  <xref linkend="ch27"/> и <xref linkend="ch25"/>). Как-то раз, уходя со
  службы около часу ночи (руководитель должен подавать хороший пример), вы
  замечаете торчащий в дверях измятый клочок бумаги (содержание которого
  воспроизведено на <xref linkend="ch24-crypto"/>). Сначала вы решаете, что
  это запись содержимого памяти машины, и уже собираетесь выбросить бумажку.
  Но, присмотревшись повнимательнее, замечаете, что буквы собраны в группы по
  пять, — очень странно для УМ-1. Что бы это мло быть?</para>

  <figure xml:id="ch24-crypto">
    <title>Таинственная записка, найденная в вычислительном центре. Случайное
    вкрапление русских слов, например <xi:include
    href="build/generated/text/word-dict-0.txt" parse="text"/> или <xi:include
    href="build/generated/text/word-dict-1.txt" parse="text"/>, по-видимому,
    ничего не означает. Но обратите внимание на повторение сочетаний
    <xi:include href="build/generated/text/word-len-0.txt" parse="text"/>,
    <xi:include href="build/generated/text/word-len-1.txt" parse="text"/>,
    других коротких сочетаний, а особенно повторяющуюся группу букв
    <xi:include href="build/generated/text/word-cnt-0.txt"
    parse="text"/></title>

    <titleabbrev>Таинственная записка</titleabbrev>

    <programlisting><xi:include href="build/generated/text/encrypted.txt"
        parse="text"/></programlisting>
  </figure>

  <para>Снова возвращаетесь в свой кабинет, пытаясь решить загадку. Бумага
  отменная, слегка пахнет мускусом; почерк явно женский и веет от него этаким
  французским шармом. Теперь, по здравом размышлении, новая сотрудница мисс
  Хари начинает казаться вам, пожалуй, немножко слишком экзотичной. Ее
  французский акцент, неизменное черное платье для коктейля, нитка черного
  жемчуга, подчеркивающая декольте, и этот будоражащий запах мускуса,
  наполняющий комнату, когда она туда входит... Она говорит, что работала
  раньше в региональном вычислительном центре Мак-Дональда в Киокаке. Что-то
  тут не так. Подождите... Неужели мисс Хари шпионит в пользу знаменитой
  французской фирмы И Бей Эм? А эта записка-шифровка, в которой все секреты
  вашего новейшего чудо-компилятора? Чтобы уличить мисс Хари, записку нужно
  расшифровать. Но как? Может, обратимся за помощью к компьютеру?</para>

  <section>
    <title>Основы шифрования</title>

    <para>ЭВМ, безусловно, может оказать помощь, иначе Управление национальной
    безопасности просто пускает на ветер деньги налогоплательщиков, закупая
    такое количество техники. Для начала необходимо как следует присмотреться
    к секретному сообщению. Возможно, что найденная записка была зашифрована
    при помощи <firstterm>простой подстановки</firstterm>, т. е. каждая буква
    первоначального текста была заменена какой-либо другой буквой согласно
    некоторому <firstterm>правилу шифрования</firstterm>. Сообщение,
    подвергшееся зашифровке, называется исходным текстом, а в результате
    получается <firstterm>шифрованный текст</firstterm>. Задача состоит в том,
    чтобы восстановить исходный текст и правило шифрования (последнее нужно
    лишь в том случае, если могут появиться другие сообщения, зашифрованные по
    тому же правилу). Будем предполагать, что исходный текст написан
    по-русски. Разбиение шифрованного текста на группы по пять букв скрывает,
    по-видимому‚ исходную структуру текста, разбитого на слова, которая была
    бы весьма ценной подсказкой, облегчающей расшифровку.</para>

    <figure xml:id="ch24-simple">
      <title>Простая подстановка по смешанному алфавиту. Обратите внимание,
      что точка заменена словом ТОЧКА</title>

      <titleabbrev>Простая подстановка</titleabbrev>

      <programlisting><xi:include
          href="build/generated/example1/alphabet-base.txt" parse="text"/>
<xi:include href="build/generated/example1/alphabet-crypt.txt" parse="text"/>

<xi:include href="build/generated/example1/space-decrypted.txt" parse="text"/>
<xi:include href="build/generated/example1/space-encrypted.txt" parse="text"/></programlisting>
    </figure>

    <para>В простейшем общем классе подстановочных шифров для построения
    правила шифрования используется некоторый <firstterm>смешанный
    алфавит</firstterm>, например перестановка обычного алфавита. На <xref
    linkend="ch24-simple"/> показан полный исходный алфавит, смешанный алфавит
    и шифрование короткого сообщения, в котором каждая буква заменяется
    соответствующей буквой смешанного алфавита. Всякий, кто увлекается
    головоломками из воскресных газет, знает, что зашифрованные такой
    подстановкой тексты расшифровываются до смешного просто: сообщения из 30
    или 40 букв зачастую оказывается для этого вполне достаточно. Тем не
    менее, слегка усовершенствовав эту систему, можно сделать ее значительно
    более надежной.</para>

    <figure xml:id="ch24-square">
      <title>Квадрат Виженера, построенный на основе смешанного алфавита,
      приведенного на <xref linkend="ch24-simple"/>.</title>

      <titleabbrev>Квадрат Виженера</titleabbrev>

      <programlisting><xi:include href="build/generated/example1/vigenere.txt"
          parse="text"/></programlisting>
    </figure>

    <para>На <xref linkend="ch24-square"/> изображен <firstterm>квадрат
    Виженера</firstterm>, построенный на основе смешанного алфавита,
    приведенного на <xref linkend="ch24-simple"/>. Сверху и по левому краю
    квадрата выписан исходный алфавит. В первой строке квадрата представлен
    смешанный алфавит. Во второй строке тот же алфавит циклически сдвинут на
    одну позицию, при этом первая буква переместилась в правый конец строки.
    Квадрат состоит из 32 смешанных алфавитов, полученных из одного смешанного
    алфавита, каждому из них соответствует та буква исходного алфавита,
    которая записана слева от него. На <xref linkend="ch24-vigenere"/>
    показано шифрование фразы при помощи <firstterm>ключевого
    слова</firstterm> <xi:include href="build/generated/example2/keyword.txt"
    parse="text"/> и данного квадрата. Ключевое слово многократно записывается
    под исходным текстом, и каждая буква исходного текста шифруется при помощи
    смешанного алфавита, соответствующего той букве ключевого слова, которая
    стоит под данной буквой исходного текста. Эта схема шифрования уже не
    поддается раскрытию при помощи простого подсчета частот букв, поскольку
    одна и та же буква исходного текста шифруется по-разному в зависимости от
    выпавшей на нее буквы ключевого слова. Кроме того, выбрав заранее список
    ключевых слов и порядок их смены, отправитель И получатель могут повысить
    секретность переписки, поскольку разным сообщениям будут соответствовать
    разные ключевые слова, благодаря чему затрудняется анализ, основанный на
    частотах букв. Тем не менее не так уж все это безнадежно.</para>

    <figure xml:id="ch24-vigenere">
      <title>Шифрование при помощи квадрата Виженера. Обратите внимание на
      повторение сочетания РБ на расстоянии 8. Второе повторение этого
      сочетания на расстоянии 2 - ложное. Статистика языка проявляется даже на
      коротких примерах.</title>

      <titleabbrev>Шифрование квадратом Виженера</titleabbrev>

      <programlisting><xi:include
          href="build/generated/example2/alphabet-base.txt" parse="text"/>
<xi:include href="build/generated/example2/alphabet-crypt.txt" parse="text"/>

<xi:include href="build/generated/example2/space-decrypted.txt" parse="text"/>
<xi:include href="build/generated/example2/space-keyword.txt" parse="text"/>
<xi:include href="build/generated/example2/space-encrypted.txt" parse="text"/></programlisting>
    </figure>
  </section>

  <section>
    <title>Как раскрыть шифр</title>

    <para>Будем предполагать, что криптограмма мисс Хари получена при помощи
    квадрата Виженера, хотя бы по той причине, что он — ее соотечественник.
    Если наше предположение неверно, методы решения позволят обнаружить это.
    Если бы сообщение было зашифровано при помощи простой подстановки, то
    расшифровать его можно было бы, подсчитав количество появлений каждой
    буквы в шифрованном тексте, поделив это количество на длину сообщения и
    сравнив полученные величины с частотами букв русского алфавита,
    приведенными на рис. 24.5. Для сообщений такой длины, как наше,
    распределения частот, если выписать их в убывающем порядке, почти
    полностью совпадут, и, таким образом, для каждой буквы исходного текста
    откроется ее двойник в шифрованном тексте. Но для квадрата Виженера такой
    простой метод уже не сработает. Необходимо определить не только смешанный
    алфавит, но и ключевое слово; поскольку каждый из этих элементов искажен
    другиим, то трудно даже догадаться, с какого конца начать.</para>

    <para>Правильной отправной точкой будет нахождение длины ключевого слова.
    Обратите внимание, что в примере на рис. <xref linkend="ch24-vigenere"/>
    первая, пятая, девятая,... буквы исходного текста зашифрованы при помощи
    одного и того же смешанного алфавита Л. Если рассматривать лишь каждую
    четвертую букву шифрованного текста, то получим распределение частот,
    подобное распределению для букв русского алфавита, поскольку буквы в этих
    позициях зашифрованы при помощи одного и того же смешанного алфавита, т.
    е. при помощи простой подстановки. Аналогично если взять каждую четвертую
    букву шифрованного текста, начиная со второй, третьей или четвертой
    позиции, то снова получим распределение частот как для букв русского
    алфавита. Существует способ измерить, насколько данное распределение
    частот подобно распределению букв алфавита. Рассмотрим индекс
    совпадения</para>

    <equation>
      <m:math display="block">
        <m:mrow>
          <m:mi>ИС</m:mi>

          <m:mo>=</m:mo>

          <m:mrow>
            <m:munderover>
              <m:mo>∑</m:mo>

              <m:mrow>
                <m:mi>i</m:mi>

                <m:mo>=</m:mo>

                <m:mi>1</m:mi>
              </m:mrow>

              <m:mi>32</m:mi>
            </m:munderover>

            <m:mfrac>
              <m:mrow>
                <m:msub>
                  <m:mi>f</m:mi>

                  <m:mi>i</m:mi>
                </m:msub>

                <m:mo>⁡</m:mo>

                <m:mfenced>
                  <m:mrow>
                    <m:msub>
                      <m:mi>f</m:mi>

                      <m:mi>i</m:mi>
                    </m:msub>

                    <m:mo>-</m:mo>

                    <m:mi>1</m:mi>
                  </m:mrow>
                </m:mfenced>
              </m:mrow>

              <m:mrow>
                <m:mrow>
                  <m:mi>N</m:mi>

                  <m:mo>⁡</m:mo>

                  <m:mfenced>
                    <m:mrow>
                      <m:mi>N</m:mi>

                      <m:mo>-</m:mo>

                      <m:mi>1</m:mi>
                    </m:mrow>
                  </m:mfenced>
                </m:mrow>
              </m:mrow>
            </m:mfrac>
          </m:mrow>
        </m:mrow>
      </m:math>
    </equation>

    <para>где <symbol>N</symbol>-количество появлений <symbol>i</symbol>-й
    буквы, а <symbol>N</symbol>-общее число рассматриваемых букв. Если все
    буквы рассматриваемого подмножества текста зашифрованы при помощи одного
    алфавита, то этот индекс совпадения должен иметь значение больше 0.045 и,
    вероятно, меньше 0.065 (теоретическое значение равно 0.055). Исходя из
    этого, алгоритм определения длины ключевого слова будет таким:</para>

    <orderedlist>
      <listitem>
        <para>Для <symbol>i</symbol> от 1 до 20 предположить, что длина
        ключевого слова равна 1, и выполнить шаги 2, 3, 4. Мы выбрали верхнюю
        границу равной 20 лишь для удобства. Разумеется, ключевое слово может
        быть и длиннее.</para>
      </listitem>

      <listitem>
        <para>Для <symbol>j</symbol> от 1 до <symbol>i</symbol> выполнить шаг
        3. В этих двух шагах будут вычислены <symbol>i</symbol> различных
        значений <symbol>ИС</symbol>.</para>
      </listitem>

      <listitem>
        <para>Построить распределение числа появления букв в позициях
        <symbol>j</symbol>, <symbol>i+j</symbol>, <symbol>2i+j</symbol>, ...,
        т. е. в каждой <symbol>i</symbol>-й позиции, начиная с
        <symbol>j</symbol>-й позиции. По формуле, приведенной выше, вычислить
        <symbol>ИС<subscript>i</subscript></symbol> для полученного
        распределения. В качестве <symbol>N</symbol> в этой формуле нужно
        использовать число букв в данном подмножестве текста, а не длину всего
        текста.</para>
      </listitem>

      <listitem>
        <para>Если все значения <symbol>ИС<subscript>1</subscript></symbol>,
        <symbol>ИС<subscript>2</subscript></symbol>, ...‚
        <symbol>ИС<subscript>i</subscript></symbol> больше 0.045, то,
        вероятно, <symbol>i</symbol> кратно длине ключевого слова. Если только
        один из <symbol>ИС</symbol> меньше 0.045, то <symbol>i</symbol> также
        может быть кратно длине ключевого слова.</para>
      </listitem>
    </orderedlist>

    <para>Проверить длину ключевого слова можно И другим способом. Найдите два
    места в шифрованном тексте, где две одинаковые буквы идут в том же
    порядке, например ЦМ в позициях 19 и 54 на <xref linkend="ch24-crypto"/>.
    Такое повторение могло произойти по двум разным причинам. Возможно, в
    соответствующих местах исходного текста были различные сочетания букв,
    которым отвечали разные части ключевого слова, и они случайно отобразились
    в одинаковые сочетания букв, либо в исходном тексте были повторения,
    которые попали на одинаковые части ключевого слова, И, таким образом,
    оказались зашифрованными дважды одним и тем же способом. Во втором случае
    расстояние между началами повторяющихся сочетаний букв должно быть кратно
    длине ключевого слова. Ксожалению‚ невозможно определить, по какой из двух
    причин произошло повторение данного сочетания букв: случайное повторение
    пар букв в шифрованном тексте довольно частое явление. Но если в
    шифрованном тексте повторяются сочетания из трех или более букв, то
    вероятность того, что это повторение произошло случайно, а не в результате
    повторения ключа, очень мала (для сочетаний из четырех и более букв она
    практически нулевая). Таким образом, другой способ выявления длины
    ключевого слова — отыскать в шифрованном тексте все пары повторяющихся
    групп из трех и более букв и измерить расстояния между ними. Число,
    которое делит 90% или более из этих расстояний, — прекрасный претендент на
    роль длины ключевого слова. Данная проверка вместе с вычислением значений
    <symbol>ИС</symbol> однозначно определяет длину ключевого слова.</para>

    <para>Предположим, нам удалось выяснить, что длина ключевого слова равна
    <symbol>k</symbol>. Тогда первоначальный шифрованный текст можно разбить
    на <symbol>k</symbol> групп <symbol>G1</symbol>, <symbol>G2</symbol>, ...,
    <symbol>Gk</symbol>, где каждая группа начинается с позиции
    <symbol>i</symbol>, <inlineequation>
        <m:math display="inline">
          <m:mrow>
            <m:mtext>1</m:mtext>

            <m:mo>≤</m:mo>

            <m:mtext>i</m:mtext>

            <m:mo>≤</m:mo>

            <m:mtext>k</m:mtext>
          </m:mrow>
        </m:math>
      </inlineequation>, и содержит каждую <symbol>k</symbol>-ю букву текста,
    начиная с <symbol>i</symbol>-й буквы. Каждая из этих <symbol>k</symbol>
    групп была зашифрована при помощи только одного алфавита, т. е. при помощи
    простой подстановки. Остается в каждой группе для каждой шифрованной буквы
    определить ее эквивалент в исходном тексте. Но здесь у нас имеется хорошее
    подспорье. Если бы был известен алфавит, по которому была зашифрована
    какая-нибудь из групп, то алфавит, по которому была зашифрована любая
    другая группа, можно было бы найти путем циклического сдвига уже
    известного алфавита на некоторое число букв. С другой стороны, определить
    исходные эквиваленты букв было бы проще, если бы удалось распределения
    числа появлений букв для различных групп скомбинировать в одно обобщенное
    распределение, поскольку, чем больше данных было использовано для
    построения какого-либо распределения, тем достовернее будут сделанные на
    его основе статистические выводы. Для построения такой комбинации
    необходимо знать относительные сдвиги между алфавитами, использованными
    для шифрования различных групп.</para>

    <para>Относительные сдвиги находятся при помощи некой модификации индекса
    совпадения. Построим для каждой группы
    <symbol>G<subscript>i</subscript></symbol> распределение числа появлений
    букв И запишем его в алфавитном порядке шифрованных букв. В табл. 24.1
    показаны распределения для сообщения, приведенного на <xref
    linkend="ch24-crypto"/>, в предположении, что <symbol>k</symbol>=7. Пусть
    <symbol>f<subscript>iα</subscript></symbol>-количество появлений буквы
    <symbol>α</symbol> алфавита <symbol>i</symbol>. Определим функцию</para>

    <equation>
      <m:math display="block">
        <m:mrow>
          <m:msub>
            <m:mi>R</m:mi>

            <m:mi>i, j, r</m:mi>
          </m:msub>

          <m:mo>=</m:mo>

          <m:mrow>
            <m:munderover>
              <m:mo>∑</m:mo>

              <m:mrow>
                <m:mi>β</m:mi>

                <m:mo>=</m:mo>

                <m:mi>1</m:mi>
              </m:mrow>

              <m:mi>32</m:mi>
            </m:munderover>

            <m:mrow>
              <m:msub>
                <m:mi>f</m:mi>

                <m:mi>i, β</m:mi>
              </m:msub>

              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

              <m:msub>
                <m:mi>f</m:mi>

                <m:mi>j, β + r</m:mi>
              </m:msub>
            </m:mrow>
          </m:mrow>
        </m:mrow>
      </m:math>
    </equation>

    <para>Считается, что если <symbol>β+r</symbol> больше 32, то происходит
    циклический возврат к началу алфавита. Чем больше значение
    <symbol>R<subscript>i,j,r</subscript></symbol>, тем больше вероятность
    того, что алфавит для группы <symbol>j</symbol> в квадрате Виженера
    находится на <symbol>r</symbol> позиций ниже алфавита для группы
    <symbol>i</symbol>. Вычислим все значения
    <symbol>R<subscript>i,j,r</subscript></symbol> (для <symbol>j ≤ i</symbol>
    их можно не вычислять благодаря свойству симметрии) и выберем
    <symbol>i</symbol> и <symbol>j</symbol>, которые дают максимальное
    значение <symbol>R<subscript>i,j,r</subscript></symbol>. Вероятно, группа
    <symbol>j</symbol> сдвинута на <symbol>r</symbol> позиций относительно
    группы <symbol>i</symbol>.</para>

    <para>Из групп <symbol>G<subscript>i</subscript></symbol> и
    <symbol>G<subscript>j</subscript></symbol> построим новую супергруппу
    <symbol>G<subscript>ij</subscript></symbol>, положив величину
    <symbol>f<subscript>ij,α</subscript></symbol>, равной
    <symbol>f<subscript>i,α</subscript> +
    f<subscript>j,α+r</subscript></symbol>. Отбросим из рассмотрения группы
    <symbol>G<subscript>i</subscript></symbol> и
    <symbol>G<subscript>j</subscript></symbol>, заменив их группой
    <symbol>G<subscript>ij</subscript></symbol>, и повторим описанный в
    последних двух абзацах процесс. После <symbol>k-1</symbol> повторений
    станут известны относительные сдвиги для всех <symbol>k</symbol>
    алфавитов. Кроме того, будет найдено обобщенное распределение частот. Для
    того чтобы найти исходные эквиваленты букв шифрованного текста,
    переупорядочим последние согласно их частотам. В результате буквы
    шифрованного текста должны расположиться в том же порядке, что и буквы
    русского алфавита (см. рис. 24.5). Теперь нетрудно восстановить весь
    квадрат Виженера и расшифровать текст. Ключевое слово можно найти,
    перебрав 32 набора из букв, относительные расстояния между которыми
    соответствуют найденным сдвигам алфавитов. Возможно, что некоторые редко
    встречающиеся буквы окажутся не на своих местах. Эту ситуацию можно
    поправить при помощи визуального исследования полученного текста. Следует
    восстановить и смешанный алфавит, и ключевое слово, поскольку они оба
    могут иметь некоторую психологическую связь с содержанием сообщения и их
    выявление поможет дополнительно убедиться в правильности решения. Между
    прочим, что же написала мисс Хари?</para>
  </section>

  <simplesect>
    <title>Тема.</title>

    <para>Напишите программу, которая в качестве входных данных воспринимает
    шифрованное сообщение и, в предположении, что оно зашифровано по схеме
    Виженера‚ печатает расшифрованный текст. Программа должна также печатать
    квадрат Виженера и ключевое слово, которые она вычисляет в процессе
    решения задачи. Специальные входные параметры должны управлять выводом
    промежуточных результатов, таких, как, например, все возможные длины
    ключевого слова, распределения частот букв для отдельных алфавитов,
    значения <symbol>ИС</symbol> и т. д., которые нужны для контроля. Эти
    результаты могут быть полезны при отладке, а также в тех, к сожалению,
    вполне реальных ситуациях, когда предложенное машиной решение оказалось не
    совсем точным. Четкость оформления выводных данных имеет большое значение:
    бестолковые распечатки лишь затрудняют работу интуиции специалиста по
    расшифровке сообщений.</para>
  </simplesect>

  <simplesect>
    <title>Указания исполнителю.</title>

    <para>Описанные здесь алгоритмы вполне понятны и легко реализуются, но
    обладают одним неприятным свойством — они не дают однозначного результата.
    Длина ключевого слова, например, будет лишь «вероятной», так что
    необходимо еще сделать обоснованный выбор одной из возможных длин.
    Аналогично алгоритмическое определение исходных эквивалентов для редко
    встречающихся букв шифрованного текста следует проверить, убедившись, что
    при расшифровке получаются правильные русские слова. Увеличивая
    статистическую информацию, доступную программе, мы получим более надежное
    основание для алгоритмических решений, но все равно эти решения должен
    проверить человек. Помимо указанных алгоритмов в вашей программе должны
    быть реализованы средства, позволяющие подтвердить обоснованность выводов,
    которые делает программа. Один хороший способ обеспечить такую оценочную
    функцию — написать программу в рамках какой-либо диалоговой системы, чтобы
    программа и пользователь смогли совместно обсудить качество каждого
    решения до того, как оно будет окончательно принято. «Обсуждение» обычно
    состоит в том, что программа сообщает человеку факты, говорящие в пользу
    того или иного возможного решения, а человек либо принимает его, либо
    отвергает, после чего вычисление может быть продолжено.</para>

    <para>Несмотря на то что алгоритмы неоднозначны и такая расплывчатость
    обычно порождает у программиста чувство неуверенности, эту программу легко
    проверить. Первой частью работы, по-видимому, должна быть программа
    шифровки, которая воспринимает в качестве исходных данных русский текст и,
    выбрав некоторым случайным образом смешанный алфавит и ключевое слово,
    выдает квадрат Виженера и печатает зашифрованный текст в стандартном
    пятибуквенном формате. Пробелы и пунктуация должны убираться из текста
    автоматически. Эта программа должна уметь также воспринимать в качестве
    возможных параметров квадрат Виженера и ключевое слово, чтобы можно было
    повторно проверять отдельные особенности работы программы расшифровки.
    Помните о том, что для хорошего статистического поведения алгоритмов
    необходимо, чтобы сообщение было в 30-40 раз длиннее ключевого
    слова.</para>
  </simplesect>

  <simplesect>
    <title>Инструментовка.</title>

    <para>Эта задача прямо-таки создана для языка типа Снобол‚ в котором
    средства работы с текстовыми данными сочетаются с простыми арифметическими
    операциями. Хорошим кандидатом может бьхть и какой-нибудь другой язык, с
    более широким диапазоном алгебраических вычислений и с достаточными
    средствами обработки текстовых данных, например PL/I, Паскаль или XPL. Но
    какой бы язык вы ни выбрали, постарайтесь избежать представления литер
    целыми числами: требования машинного представления не должны навязывать
    некрасивое, путаное решение задачи.</para>
  </simplesect>

  <simplesect>
    <title>Длительность исполнения.</title>

    <para>Одному исполнителю на 2 недели.</para>
  </simplesect>

  <simplesect>
    <title>*Партия переводчика.</title>

    <para>При переводе на русский язык зашифрованного примера надо было
    сначала расшифровать его. Попытка сделать это с помощью описанной
    процедуры не привела к успеху. После небольшого размышления стало ясно,
    что наш ключ не подходит потому, что он от другого замка! Действительно,
    предлагаемый автором способ определения относительных сдвигов столбцов с
    помощью величин <symbol>R<subscript>i,j,r</subscript></symbol> исходит из
    того, что два столбца отличаются, кроме случайных отклонений, циклическим
    сдвигом на величину, равную разности номеров двух букв ключевого слова.
    Это свойство будет иметь место, если несколько изменить способ шифрования.
    В нашем случае вместо <symbol>R<subscript>i,j,r</subscript></symbol>
    следует использовать числа <symbol>p<subscript>i,j,r</subscript></symbol>,
    вычисляемые, как описано ниже.</para>

    <para>Пусть число букв алфавита равно <symbol>n</symbol>. Будем обозначать
    <symbol>i</symbol>-ю букву алфавита
    <symbol>х<subscript>i</subscript></symbol> или
    <symbol>y<subscript>i</subscript></symbol>, в зависимости от того, идет
    речь об исходном тексте или о зашифрованном. Нам известны средняя частота
    <symbol>p<subscript>i</subscript>=p(x<subscript>i</subscript>)</symbol>
    появления <symbol>i</symbol>-й буквы в русском языке, число
    <symbol>f<subscript>k,j</subscript></symbol> появлений
    <symbol>i</symbol>-й буквы в <symbol>k</symbol>-й группе зашифрованного
    текста, общее число <symbol>N<subscript>k</subscript></symbol> букв в
    <symbol>k</symbol>-й группе. Определим вероятности
    <symbol>p<subscript>k</subscript>(y<subscript>j</subscript>|x<subscript>i</subscript>)</symbol>
    появления фактического числа букв
    <symbol>f<subscript>k,j</subscript></symbol>, если буква
    <symbol>у<subscript>i</subscript></symbol> в <symbol>k</symbol>-й группе
    обозначает букву <symbol>х<subscript>i</subscript></symbol> исходного
    текста. Эти вероятности подчиняются биномиальному распределению.</para>

    <equation>
      <m:math display="block">
        <m:mrow>
          <m:mrow>
            <m:msub>
              <m:mi>p</m:mi>

              <m:mi>k</m:mi>
            </m:msub>

            <m:mfenced>
              <m:mrow>
                <m:msub>
                  <m:mi>y</m:mi>

                  <m:mi>j</m:mi>
                </m:msub>

                <m:mo>|</m:mo>

                <m:msub>
                  <m:mi>x</m:mi>

                  <m:mi>i</m:mi>
                </m:msub>
              </m:mrow>
            </m:mfenced>
          </m:mrow>

          <m:mo>=</m:mo>

          <m:mrow>
            <m:msubsup>
              <m:mi>C</m:mi>

              <m:msub>
                <m:mi>N</m:mi>

                <m:mi>k</m:mi>
              </m:msub>

              <m:msub>
                <m:mi>f</m:mi>

                <m:mrow>
                  <m:mi>k</m:mi>

                  <m:mo>,</m:mo>

                  <m:mi>j</m:mi>
                </m:mrow>
              </m:msub>
            </m:msubsup>

            <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

            <m:msubsup>
              <m:mi>p</m:mi>

              <m:mi>i</m:mi>

              <m:msub>
                <m:mi>f</m:mi>

                <m:mrow>
                  <m:mi>k</m:mi>

                  <m:mo>,</m:mo>

                  <m:mi>j</m:mi>
                </m:mrow>
              </m:msub>
            </m:msubsup>

            <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

            <m:msup>
              <m:mrow>
                <m:mo>(</m:mo>

                <m:mrow>
                  <m:mi>1</m:mi>

                  <m:mo>-</m:mo>

                  <m:msub>
                    <m:mi>p</m:mi>

                    <m:mi>i</m:mi>
                  </m:msub>
                </m:mrow>

                <m:mo>)</m:mo>
              </m:mrow>

              <m:mrow>
                <m:msub>
                  <m:mi>N</m:mi>

                  <m:mi>k</m:mi>
                </m:msub>

                <m:mo>-</m:mo>

                <m:msub>
                  <m:mi>f</m:mi>

                  <m:mrow>
                    <m:mi>k</m:mi>

                    <m:mo>,</m:mo>

                    <m:mi>j</m:mi>
                  </m:mrow>
                </m:msub>
              </m:mrow>
            </m:msup>
          </m:mrow>
        </m:mrow>
      </m:math>
    </equation>

    <para>Далее найдем по формуле Байеса вероятности
    <symbol>p<subscript>k</subscript>(y<subscript>j</subscript>|x<subscript>i</subscript>)</symbol>
    того, что буква <symbol>у<subscript>i</subscript></symbol> в
    <symbol>k</symbol>-й группе означает букву
    <symbol>х<subscript>i</subscript></symbol> исходного текста. Априорные
    вероятности гипотез примем равными <symbol>1/n</symbol>.</para>

    <equation>
      <m:math display="block">
        <m:mrow>
          <m:mrow>
            <m:msub>
              <m:mi>p</m:mi>

              <m:mi>k</m:mi>
            </m:msub>

            <m:mfenced>
              <m:mrow>
                <m:msub>
                  <m:mi>y</m:mi>

                  <m:mi>j</m:mi>
                </m:msub>

                <m:mo>|</m:mo>

                <m:msub>
                  <m:mi>x</m:mi>

                  <m:mi>i</m:mi>
                </m:msub>
              </m:mrow>
            </m:mfenced>
          </m:mrow>

          <m:mo>=</m:mo>

          <m:mfrac>
            <m:mrow>
              <m:mrow>
                <m:mo>(</m:mo>

                <m:mrow>
                  <m:mi>1</m:mi>

                  <m:mo>/</m:mo>

                  <m:mi>n</m:mi>
                </m:mrow>

                <m:mo>)</m:mo>
              </m:mrow>

              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

              <m:msub>
                <m:mi>p</m:mi>

                <m:mi>k</m:mi>
              </m:msub>

              <m:mfenced>
                <m:mrow>
                  <m:msub>
                    <m:mi>y</m:mi>

                    <m:mi>j</m:mi>
                  </m:msub>

                  <m:mo>|</m:mo>

                  <m:msub>
                    <m:mi>x</m:mi>

                    <m:mi>i</m:mi>
                  </m:msub>
                </m:mrow>
              </m:mfenced>
            </m:mrow>

            <m:mrow>
              <m:munderover>
                <m:mo>∑</m:mo>

                <m:mrow>
                  <m:mi>m</m:mi>

                  <m:mo>=</m:mo>

                  <m:mi>1</m:mi>
                </m:mrow>

                <m:mi>n</m:mi>
              </m:munderover>

              <m:mrow>
                <m:mrow>
                  <m:mo>(</m:mo>

                  <m:mrow>
                    <m:mi>1</m:mi>

                    <m:mo>/</m:mo>

                    <m:mi>n</m:mi>
                  </m:mrow>

                  <m:mo>)</m:mo>
                </m:mrow>

                <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                <m:msub>
                  <m:mi>p</m:mi>

                  <m:mi>k</m:mi>
                </m:msub>

                <m:mfenced>
                  <m:mrow>
                    <m:msub>
                      <m:mi>y</m:mi>

                      <m:mi>j</m:mi>
                    </m:msub>

                    <m:mo>|</m:mo>

                    <m:msub>
                      <m:mi>x</m:mi>

                      <m:mi>m</m:mi>
                    </m:msub>
                  </m:mrow>
                </m:mfenced>
              </m:mrow>
            </m:mrow>
          </m:mfrac>

          <m:mo>=</m:mo>

          <m:mfrac>
            <m:mrow>
              <m:msub>
                <m:mi>p</m:mi>

                <m:mi>k</m:mi>
              </m:msub>

              <m:mfenced>
                <m:mrow>
                  <m:msub>
                    <m:mi>y</m:mi>

                    <m:mi>j</m:mi>
                  </m:msub>

                  <m:mo>|</m:mo>

                  <m:msub>
                    <m:mi>x</m:mi>

                    <m:mi>i</m:mi>
                  </m:msub>
                </m:mrow>
              </m:mfenced>
            </m:mrow>

            <m:mrow>
              <m:munderover>
                <m:mo>∑</m:mo>

                <m:mrow>
                  <m:mi>m</m:mi>

                  <m:mo>=</m:mo>

                  <m:mi>1</m:mi>
                </m:mrow>

                <m:mi>n</m:mi>
              </m:munderover>

              <m:mrow>
                <m:msub>
                  <m:mi>p</m:mi>

                  <m:mi>k</m:mi>
                </m:msub>

                <m:mfenced>
                  <m:mrow>
                    <m:msub>
                      <m:mi>y</m:mi>

                      <m:mi>j</m:mi>
                    </m:msub>

                    <m:mo>|</m:mo>

                    <m:msub>
                      <m:mi>x</m:mi>

                      <m:mi>m</m:mi>
                    </m:msub>
                  </m:mrow>
                </m:mfenced>
              </m:mrow>
            </m:mrow>
          </m:mfrac>
        </m:mrow>
      </m:math>
    </equation>

    <para>Рассмотрим теперь пару групп (столбцов табл. 24.1)
    <symbol>k</symbol> и <symbol>l</symbol>. Будем говорить, что между ними
    имеется сдвиг <symbol>r</symbol>, если каждой букве
    <symbol>y<subscript>j</subscript></symbol> зашифрованного текста в
    <symbol>l</symbol>-й группе соответствует буква исходного текста на
    <symbol>r</symbol> большая (по модулю <symbol>n</symbol>), чем в
    <symbol>k</symbol>-й группе. Это означает, что в ключевом слове
    <symbol>l</symbol>-я буква на <symbol>r</symbol> меньше
    <symbol>k</symbol>-й. Для оценки вероятностей
    <symbol>p<subscript>k,l,r</subscript></symbol> того, что между
    <symbol>k</symbol>-й и <symbol>l</symbol>-й групнами имеется сдвиг
    <symbol>r</symbol>, вычислим величины</para>

    <equation>
      <m:math display="block">
        <m:mrow>
          <m:msub>
            <m:mover>
              <m:mi>p</m:mi>

              <m:mo>~</m:mo>
            </m:mover>

            <m:mi>k,l,r</m:mi>
          </m:msub>

          <m:mo>=</m:mo>

          <m:mrow>
            <m:munderover>
              <m:mo>∏</m:mo>

              <m:mrow>
                <m:mi>j</m:mi>

                <m:mo>=</m:mo>

                <m:mi>1</m:mi>
              </m:mrow>

              <m:mi>n</m:mi>
            </m:munderover>

            <m:mrow>
              <m:mo>(</m:mo>

              <m:mrow>
                <m:munderover>
                  <m:mo>∑</m:mo>

                  <m:mrow>
                    <m:mi>i</m:mi>

                    <m:mo>=</m:mo>

                    <m:mi>1</m:mi>
                  </m:mrow>

                  <m:mi>n</m:mi>
                </m:munderover>

                <m:mrow>
                  <m:mrow>
                    <m:msub>
                      <m:mi>p</m:mi>

                      <m:mi>k</m:mi>
                    </m:msub>

                    <m:mfenced>
                      <m:mrow>
                        <m:msub>
                          <m:mi>x</m:mi>

                          <m:mi>i</m:mi>
                        </m:msub>

                        <m:mo>|</m:mo>

                        <m:msub>
                          <m:mi>y</m:mi>

                          <m:mi>j</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mfenced>
                  </m:mrow>

                  <m:mo>×</m:mo>

                  <m:mrow>
                    <m:msub>
                      <m:mi>p</m:mi>

                      <m:mi>l</m:mi>
                    </m:msub>

                    <m:mfenced>
                      <m:mrow>
                        <m:msub>
                          <m:mi>x</m:mi>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>⊕</m:mo>

                            <m:mi>r</m:mi>
                          </m:mrow>
                        </m:msub>

                        <m:mo>|</m:mo>

                        <m:msub>
                          <m:mi>y</m:mi>

                          <m:mi>j</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mfenced>
                  </m:mrow>
                </m:mrow>
              </m:mrow>

              <m:mo>)</m:mo>
            </m:mrow>
          </m:mrow>
        </m:mrow>
      </m:math>
    </equation>

    <para>Символы ⊕, ⊖ означают сложение и вычитание по модулю
    <symbol>n</symbol>. Величина
    <symbol>p<subscript>k,l,r</subscript></symbol> есть вероятность
    фактического распределения числа появлений букв при условии, что имеет
    место сдвиг <symbol>r</symbol>. Здесь не учитывается, что разные
    <symbol>y<subscript>j</subscript></symbol> соответствуют разным
    <symbol>x<subscript>i</subscript></symbol>. Значения
    <symbol>p<subscript>k,l,r</subscript></symbol> получаются по формуле
    Байеса</para>

    <equation>
      <m:math display="block">
        <m:mrow>
          <m:msub>
            <m:mi>p</m:mi>

            <m:mi>k,l,r</m:mi>
          </m:msub>

          <m:mo>=</m:mo>

          <m:mfrac>
            <m:msub>
              <m:mover>
                <m:mi>p</m:mi>

                <m:mo>~</m:mo>
              </m:mover>

              <m:mi>k,l,r</m:mi>
            </m:msub>

            <m:mrow>
              <m:munderover>
                <m:mo>∑</m:mo>

                <m:mrow>
                  <m:mi>s</m:mi>

                  <m:mo>=</m:mo>

                  <m:mi>0</m:mi>
                </m:mrow>

                <m:mrow>
                  <m:mi>n</m:mi>

                  <m:mo>-</m:mo>

                  <m:mi>1</m:mi>
                </m:mrow>
              </m:munderover>

              <m:msub>
                <m:mover>
                  <m:mi>p</m:mi>

                  <m:mo>~</m:mo>
                </m:mover>

                <m:mi>k,l,s</m:mi>
              </m:msub>
            </m:mrow>
          </m:mfrac>
        </m:mrow>
      </m:math>
    </equation>
  </simplesect>
</chapter>
