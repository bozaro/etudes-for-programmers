<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="ch08" xml:lang="ru"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:m="http://www.w3.org/1998/Math/MathML">
  <title>Тезей,</title>

  <subtitle>или автоматическое построение лабиринтов</subtitle>

  <para>Тезей должен был найти выход из Критского лабиринта или погибнуть от
  руки Минотавра. Но что поразительно: найти вход в лабиринт— задача не менее
  трудная.</para>

  <para>Здесь не представляется возможным описать все мыслимые лабиринты, да
  это и не требуется. Мы займемся простыми лабиринтами, построенными на
  прямоугольнике <inlineequation>
      <m:math display="inline">
        <m:mrow>
          <m:mi>m</m:mi>

          <m:mo>×</m:mo>

          <m:mi>n</m:mi>
        </m:mrow>
      </m:math>
    </inlineequation>, где <varname>n</varname>,
  <varname>m</varname>-положительные целые числа. Внутри и на границах
  прямоугольника поставлены стенки по ребрам покрывающей его единичной
  квадратной сетки. Чтобы построить из прямоугольника лабиринт, выбьем одну
  единичную стенку на одной из сторон прямоугольника (получится вход в
  лабиринт); выбьем одну единичную стенку на противоположной стороне
  (получится выход) и еще удалим какое-то число строго внутренних стенок.
  Говорят, что лабиринт имеет решение, если между входом и выходом внутри
  лабиринта есть путь в виде ломаной, не имеющей общих точек со стенками.
  Решение единственно, если любые два таких пути проходят через одни и те же
  внутренние ячейки сетки. На <xref linkend="ch08-maze"/> приведен пример
  лабиринта <inlineequation>
      <m:math display="inline">
        <m:mrow>
          <m:mi>6</m:mi>

          <m:mo>×</m:mo>

          <m:mi>6</m:mi>
        </m:mrow>
      </m:math>
    </inlineequation>.</para>

  <figure xml:id="ch08-maze">
    <title>Пример лабиринта.</title>

    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="maze.svg" width="50%"/>
      </imageobject>
    </mediaobject>
  </figure>

  <simplesect>
    <title>Тема</title>

    <para>Напишите программу, которая по исходным данным т и п строит
    прямоугольный лабиринт <inlineequation>
        <m:math display="inline">
          <m:mrow>
            <m:mi>m</m:mi>

            <m:mo>×</m:mo>

            <m:mi>n</m:mi>
          </m:mrow>
        </m:math>
      </inlineequation> (проверьте, допустимы ли заданные <varname>m</varname>
    и <varname>n</varname>). Предусмотрите, чтобы программа при каждом
    обращении к ней порождала разные лабиринты. Лабиринт должен иметь
    единственное решение, и, чтобы получившийся лабиринт был интересным, все
    ячейки должны быть соединены с основным путем, дающим решение. Если в
    вашем распоряжении имеется хорошее графическое устройство, используйте его
    для изображения лабиринтов, в противном случае придумайте систему
    обозначений для записи лабиринтов или выводите лабиринты на АЦПУ.</para>
  </simplesect>

  <simplesect>
    <title>Указания исполнителю</title>

    <para>Теоретически нельзя удовлетворить требованию, чтобы любые два
    лабиринта (даже при одинаковых <varname>m</varname> и
    <varname>n</varname>) были различны, поскольку существует лишь конечное
    число лабиринтов любого наперед заданного размера, а программу можно
    вызвать большее число раз. Однако число лабиринтов какого-нибудь размера
    очень велико, и поэтому вероятность повторения лабиринта можно сделать
    очень маленькой. Практически это достигается, если программа будет
    производить «случайный» выбор различных вариантов, опираясь на какое-либо
    доступное ей, но неуправляемое значение (обычно берут дату и время вызова
    программы). Варианты, между которыми выбирает программа, это, например,
    положение входа и выхода и положение хотя бы нескольких внутренних
    разрушаемых стенок. При отладке разумно будет отключить механизм
    случайного выбора, чтобы изменения результата работы вызывались только
    изменениями самой программы.</para>

    <para>Один из возможных подходов к решению таков. Выбираем вход; затем,
    начав от него, добавляем по одной ячейке к главному пути-решению, пока он
    не достигнет выходной стороны. После этого удаляем некоторые внутренние
    стенки так, чтобы все клетки оказались соединенными с главным путем. Чтобы
    главный путь не получился прямым коридором, следует при его построении
    предусмотреть случайные повороты. Программа должна также следить за тем,
    чтобы при построении главного пути или при открытии боковых ячеек не
    нарушалась единственность решения. Наблюдательный читатель заметит, что
    определение единственности решения не годится в случае, когда путь заходит
    в боковой тупик И затем возвращается. Вы можете попробовать разработать в
    том же духе формально корректное определение.</para>
  </simplesect>

  <simplesect>
    <title>Инструментовка</title>

    <para>Программу можно написать почти на любом из процедурных языков.
    Используйте эту программу для сравнения языков с точки зрения управляющих
    структур, встроенных структур данных И эффективности выполнения.</para>
  </simplesect>

  <simplesect>
    <title>Длительность исполнения</title>

    <para>Одному исполнителю на З недели.</para>
  </simplesect>
</chapter>
