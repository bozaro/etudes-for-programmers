<?xml version="1.0" encoding="UTF-8"?>
<book version="5.0" xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:svg="http://www.w3.org/2000/svg"
      xmlns:m="http://www.w3.org/1998/Math/MathML"
      xmlns:html="http://www.w3.org/1999/xhtml"
      xmlns:db="http://docbook.org/ns/docbook"
      lang="ru">
  <info>
    <title/>

    <author>
      <personname><firstname/><surname/></personname>

      <affiliation>
        <orgname/>
      </affiliation>
    </author>

    <pubdate/>
  </info>

  <chapter>
    <title>Тезей,</title>

    <subtitle>или автоматическое построение лабиринтов</subtitle>

    <para>Тезей должен был найти выход из Критского лабиринта или погибнуть от
    руки Минотавра. Но что поразительно: найти вход в лабиринт— задача не
    менее трудная.</para>

    <para>Здесь не представляется возможным описать все мыслимые лабиринты, да
    это и не требуется. Мы займемся простыми лабиринтами, построенными на
    прямоугольнике <inlineequation>
        <m:math display="inline">
          <m:mrow>
            <m:mi>m</m:mi>

            <m:mo>×</m:mo>

            <m:mi>n</m:mi>
          </m:mrow>
        </m:math>
      </inlineequation>, где <varname>n</varname>,
    <varname>m</varname>-положительные целые числа. Внутри и на границах
    прямоугольника поставлены стенки по ребрам покрывающей его единичной
    квадратной сетки. Чтобы построить из прямоугольника лабиринт, выбьем одну
    единичную стенку на одной из сторон прямоугольника (получится вход в
    лабиринт); выбьем одну единичную стенку на противоположной стороне
    (получится выход) и еще удалим какое-то число строго внутренних стенок.
    Говорят, что лабиринт имеет решение, если между входом и выходом внутри
    лабиринта есть путь в виде ломаной, не имеющей общих точек со стенками.
    Решение единственно, если любые два таких пути проходят через одни и те же
    внутренние ячейки сетки. На <xref linkend="ch08-maze"/> приведен пример
    лабиринта <inlineequation>
        <m:math display="inline">
          <m:mrow>
            <m:mi>6</m:mi>

            <m:mo>×</m:mo>

            <m:mi>6</m:mi>
          </m:mrow>
        </m:math>
      </inlineequation>.</para>

    <figure xml:id="ch08-maze">
      <title>Пример лабиринта.</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="ch08/maze.svg" width="50%"/>
        </imageobject>
      </mediaobject>
    </figure>

    <simplesect>
      <title>Тема</title>

      <para>Напишите программу, которая по исходным данным т и п строит
      прямоугольный лабиринт <inlineequation>
          <m:math display="inline">
            <m:mrow>
              <m:mi>m</m:mi>

              <m:mo>×</m:mo>

              <m:mi>n</m:mi>
            </m:mrow>
          </m:math>
        </inlineequation> (проверьте, допустимы ли заданные
      <varname>m</varname> и <varname>n</varname>). Предусмотрите, чтобы
      программа при каждом обращении к ней порождала разные лабиринты.
      Лабиринт должен иметь единственное решение, и, чтобы получившийся
      лабиринт был интересным, все ячейки должны быть соединены с основным
      путем, дающим решение. Если в вашем распоряжении имеется хорошее
      графическое устройство, используйте его для изображения лабиринтов, в
      противном случае придумайте систему обозначений для записи лабиринтов
      или выводите лабиринты на АЦПУ.</para>
    </simplesect>

    <simplesect>
      <title>Указания исполнителю</title>

      <para>Теоретически нельзя удовлетворить требованию, чтобы любые два
      лабиринта (даже при одинаковых <varname>m</varname> и
      <varname>n</varname>) были различны, поскольку существует лишь конечное
      число лабиринтов любого наперед заданного размера, а программу можно
      вызвать большее число раз. Однако число лабиринтов какого-нибудь размера
      очень велико, и поэтому вероятность повторения лабиринта можно сделать
      очень маленькой. Практически это достигается, если программа будет
      производить «случайный» выбор различных вариантов, опираясь на
      какое-либо доступное ей, но неуправляемое значение (обычно берут дату и
      время вызова программы). Варианты, между которыми выбирает программа,
      это, например, положение входа и выхода и положение хотя бы нескольких
      внутренних разрушаемых стенок. При отладке разумно будет отключить
      механизм случайного выбора, чтобы изменения результата работы вызывались
      только изменениями самой программы.</para>

      <para>Один из возможных подходов к решению таков. Выбираем вход; затем,
      начав от него, добавляем по одной ячейке к главному пути-решению, пока
      он не достигнет выходной стороны. После этого удаляем некоторые
      внутренние стенки так, чтобы все клетки оказались соединенными с главным
      путем. Чтобы главный путь не получился прямым коридором, следует при его
      построении предусмотреть случайные повороты. Программа должна также
      следить за тем, чтобы при построении главного пути или при открытии
      боковых ячеек не нарушалась единственность решения. Наблюдательный
      читатель заметит, что определение единственности решения не годится в
      случае, когда путь заходит в боковой тупик И затем возвращается. Вы
      можете попробовать разработать в том же духе формально корректное
      определение.</para>
    </simplesect>

    <simplesect>
      <title>Инструментовка</title>

      <para>Программу можно написать почти на любом из процедурных языков.
      Используйте эту программу для сравнения языков с точки зрения
      управляющих структур, встроенных структур данных И эффективности
      выполнения.</para>
    </simplesect>

    <simplesect>
      <title>Длительность исполнения</title>

      <para>Одному исполнителю на З недели.</para>
    </simplesect>
  </chapter>

  <chapter>
    <title>Секрет фирмы</title>

    <subtitle>или математический подход к раскрытию шифров</subtitle>

    <para>Представьте себе такую ситуацию. Благодаря выдающимся
    профессиональным познаниям и незаурядным программистским способностям вас
    выдвинули на должность руководителя большой группы сотрудников,
    занимающихся разработкой суперновейшего и пока еще секретного
    Мини-компилятора для ЭВМ УМ-1 (см гл. 27 и 25). Как-то раз, уходя со
    службы около часу ночи (руководитель должен подавать хороший пример), вы
    замечаете торчащий в дверях измятый клочок бумаги (содержание которого
    воспроизведено на рис. 24.1). Сначала вы решаете, что это запись
    содержимого памяти машины, и уже собираетесь выбросить бумажку. Но,
    присмотревшись повнимательнее, замечаете, что буквы собраны в группы по
    пять, — очень странно для УМ-1. Что бы это могло быть?</para>

    <para>Снова возвращаетесь в свой кабинет, пытаясь решить загадку. Бумага
    отменная, слегка пахнет мускусом; почерк явно женский и веет от него
    этаким французским шармом. Теперь, по здравом размышлении, новая
    сотрудница мисс Хари начинает казаться вам, пожалуй, немножко слишком
    экзотичной. Ее французский акцент, неизменное черное платье для коктейля,
    нитка черного жемчуга, подчеркивающая декольте, и этот будоражащий запах
    мускуса, наполняющий комнату, когда она туда входит... Она говорит, что
    работала раньше в региональном вычислительном центре Мак-Дональда в
    Киокаке. Что-то тут не так. Подождите... Неужели мисс Хари шпионит в
    пользу знаменитой французской фирмы И Бей Эм? А эта записка-шифровка, в
    которой все секреты вашего новейшего чудо-компилятора? Чтобы уличить мисс
    Хари, записку нужно расшифровать. Но как? Может, обратимся за помощью к
    компьютеру?</para>

    <section>
      <title>Основы шифрования</title>

      <para>ЭВМ, безусловно, может оказать помощь, иначе Управление
      национальной безопасности просто пускает на ветер деньги
      налогоплательщиков, закупая такое количество техники. Для начала
      необходимо как следует присмотреться к секретному сообщению. Возможно,
      что найденная записка была зашифрована при помощи простой подстановки,
      т. е. каждая буква первоначального текста была заменена какой-либо
      другой буквой согласно некоторому правилу шифрования. Сообщение,
      подвергшееся зашифровке, называется исходным текстом, а в результате
      получается шифрованный текст. Задача состоит в том, чтобы восстановить
      исходный текст и правило шифрования (последнее нужно лишь в том случае,
      если могут появиться другие сообщения, зашифрованные по тому же
      правилу). Будем предполагать, что исходный текст написан по-русски.
      Разбиение шифрованного текста на группы по пять букв скрывает,
      по-видимому‚ исходную структуру текста, разбитого на слова, которая была
      бы весьма ценной подсказкой, облегчающей расшифровку.</para>

      <para>В простейшем общем классе подстановочных шифров для построения
      правила шифрования используется некоторый смешанный алфавит, например
      перестановка обычного алфавита. На рис. 24.2 показан полный исходный
      алфавит, смешанный алфавит и шифрование короткого сообщения, в котором
      каждая буква заменяется соответствующей буквой смешанного алфавита.
      Всякий, кто увлекается головоломками из воскресных газет, знает, что
      зашифрованные такой подстановкой тексты расшифровываются до смешного
      просто: сообщения из 30 или 40 букв зачастую оказывается для этого
      вполне достаточно. Тем не менее, слегка усовершенствовав эту систему,
      можно сделать ее значительно более надежной.</para>

      <para>На рис. 24.3 изображен квадрат Виженера, построенный на основе
      смешанного алфавита, приведенного на рис. 24.2. Сверху и по левому краю
      квадрата выписан исходный алфавит. В первой строке квадрата представлен
      смешанный алфавит. Во второй строке тот же алфавит циклически сдвинут на
      одну позицию, при этом первая буква переместилась в правый конец строки.
      Квадрат состоит из 32 смешанных алфавитов, полученных из одного
      смешанного алфавита, каждому из них соответствует та буква исходного
      алфавита, которая записана слева от него. На рис. 24.4 показано
      шифрование фразы при помощи ключевого слова ЛИСП и данного квадрата.
      Ключевое слово многократно записывается под исходным текстом, и каждая
      буква исходного текста шифруется при помощи смешанного алфавита,
      соответствующего той букве ключевого слова, которая стоит под данной
      буквой исходного текста. Эта схема шифрования уже не поддается раскрытию
      при помощи простого подсчета частот букв, поскольку одна и та же буква
      исходного текста шифруется по-разному в зависимости от выпавшей на нее
      буквы ключевого слова. Кроме того, выбрав заранее список ключевых слов и
      порядок их смены, отправитель И получатель могут повысить секретность
      переписки, поскольку разным сообщениям будут соответствовать разные
      ключевые слова, благодаря чему затрудняется анализ, основанный на
      частотах букв. Тем не менее не так уж все это безнадежно.</para>
    </section>

    <section>
      <title>Как раскрыть шифр</title>

      <para>Будем предполагать, что криптограмма мисс Хари получена при помощи
      квадрата Виженера, хотя бы по той причине, что он — ее соотечественник.
      Если наше предположение неверно, методы решения позволят обнаружить это.
      Если бы сообщение было зашифровано при помощи простой подстановки, то
      расшифровать его можно было бы, подсчитав количество появлений каждой
      буквы в шифрованном тексте, поделив это количество на длину сообщения и
      сравнив полученные величины с частотами букв русского алфавита,
      приведенными на рис. 24.5. Для сообщений такой длины, как наше,
      распределения частот, если выписать их в убывающем порядке, почти
      полностью совпадут, и, таким образом, для каждой буквы исходного текста
      откроется ее двойник в шифрованном тексте. Но для квадрата Виженера
      такой простой метод уже не сработает. Необходимо определить не только
      смешанный алфавит, но и ключевое слово; поскольку каждый из этих
      элементов искажен другиим, то трудно даже догадаться, с какого конца
      начать.</para>

      <para>Правильной отправной точкой будет нахождение длины ключевого
      слова. Обратите внимание, что в примере на рис. 24.4 первая, пятая,
      девятая,... буквы исходного текста зашифрованы при помощи одного и того
      же смешанного алфавита Л. Если рассматривать лишь каждую четвертую букву
      шифрованного текста, то получим распределение частот, подобное
      распределению для букв русского алфавита, поскольку буквы в этих
      позициях зашифрованы при помощи одного и того же смешанного алфавита, т.
      е. при помощи простой подстановки. Аналогично если взять каждую
      четвертую букву шифрованного текста, начиная со второй, третьей или
      четвертой позиции, то снова получим распределение частот как для букв
      русского алфавита. Существует способ измерить, насколько данное
      распределение частот подобно распределению букв алфавита. Рассмотрим
      индекс совпадения</para>

      <equation>
        <m:math display="block">
          <m:mrow>
            <m:mi>ИС</m:mi>

            <m:mo>=</m:mo>

            <m:mrow>
              <m:munderover>
                <m:mo>∑</m:mo>

                <m:mrow>
                  <m:mi>i</m:mi>

                  <m:mo>=</m:mo>

                  <m:mi>1</m:mi>
                </m:mrow>

                <m:mi>32</m:mi>
              </m:munderover>

              <m:mfrac>
                <m:mrow>
                  <m:msub>
                    <m:mi>f</m:mi>

                    <m:mi>i</m:mi>
                  </m:msub>

                  <m:mo>⁡</m:mo>

                  <m:mfenced>
                    <m:mrow>
                      <m:msub>
                        <m:mi>f</m:mi>

                        <m:mi>i</m:mi>
                      </m:msub>

                      <m:mo>-</m:mo>

                      <m:mi>1</m:mi>
                    </m:mrow>
                  </m:mfenced>
                </m:mrow>

                <m:mrow>
                  <m:mrow>
                    <m:mi>N</m:mi>

                    <m:mo>⁡</m:mo>

                    <m:mfenced>
                      <m:mrow>
                        <m:mi>N</m:mi>

                        <m:mo>-</m:mo>

                        <m:mi>1</m:mi>
                      </m:mrow>
                    </m:mfenced>
                  </m:mrow>
                </m:mrow>
              </m:mfrac>
            </m:mrow>
          </m:mrow>
        </m:math>
      </equation>

      <para>где <symbol>N</symbol>-количество появлений <symbol>i</symbol>-й
      буквы, а <symbol>N</symbol>-общее число рассматриваемых букв. Если все
      буквы рассматриваемого подмножества текста зашифрованы при помощи одного
      алфавита, то этот индекс совпадения должен иметь значение больше 0.045
      и, вероятно, меньше 0.065 (теоретическое значение равно 0.055). Исходя
      из этого, алгоритм определения длины ключевого слова будет таким:</para>

      <orderedlist>
        <listitem>
          <para>Для <symbol>i</symbol> от 1 до 20 предположить, что длина
          ключевого слова равна 1, и выполнить шаги 2, 3, 4. Мы выбрали
          верхнюю границу равной 20 лишь для удобства. Разумеется, ключевое
          слово может быть и длиннее.</para>
        </listitem>

        <listitem>
          <para>Для <symbol>j</symbol> от 1 до <symbol>i</symbol> выполнить
          шаг 3. В этих двух шагах будут вычислены <symbol>i</symbol>
          различных значений <symbol>ИС</symbol>.</para>
        </listitem>

        <listitem>
          <para>Построить распределение числа появления букв в позициях
          <symbol>j</symbol>, <symbol>i+j</symbol>, <symbol>2i+j</symbol>,
          ..., т. е. в каждой <symbol>i</symbol>-й позиции, начиная с
          <symbol>j</symbol>-й позиции. По формуле, приведенной выше,
          вычислить <symbol>ИС<subscript>i</subscript></symbol> для
          полученного распределения. В качестве <symbol>N</symbol> в этой
          формуле нужно использовать число букв в данном подмножестве текста,
          а не длину всего текста.</para>
        </listitem>

        <listitem>
          <para>Если все значения <symbol>ИС<subscript>1</subscript></symbol>,
          <symbol>ИС<subscript>2</subscript></symbol>, ...‚
          <symbol>ИС<subscript>i</subscript></symbol> больше 0.045, то,
          вероятно, <symbol>i</symbol> кратно длине ключевого слова. Если
          только один из <symbol>ИС</symbol> меньше 0.045, то
          <symbol>i</symbol> также может быть кратно длине ключевого
          слова.</para>
        </listitem>
      </orderedlist>

      <para>Проверить длину ключевого слова можно И другим способом. Найдите
      два места в шифрованном тексте, где две одинаковые буквы идут в том же
      порядке, например ЦМ в позициях 19 И 54 на рис. 24.1. Такое повторение
      могло произойти по двум разным причинам. Возможно, в соответствующих
      местах исходного текста были различные сочетания букв, которым отвечали
      разные части ключевого слова, и они случайно отобразились в одинаковые
      сочетания букв, либо в исходном тексте были повторения, которые попали
      на одинаковые части ключевого слова, И, таким образом, оказались
      зашифрованными дважды одним и тем же способом. Во втором случае
      расстояние между началами повторяющихся сочетаний букв должно быть
      кратно длине ключевого слова. Ксожалению‚ невозможно определить, по
      какой из двух причин произошло повторение данного сочетания букв:
      случайное повторение пар букв в шифрованном тексте довольно частое
      явление. Но если в шифрованном тексте повторяются сочетания из трех или
      более букв, то вероятность того, что это повторение произошло случайно,
      а не в результате повторения ключа, очень мала (для сочетаний из четырех
      и более букв она практически нулевая). Таким образом, другой способ
      выявления длины ключевого слова — отыскать в шифрованном тексте все пары
      повторяющихся групп из трех и более букв и измерить расстояния между
      ними. Число, которое делит 90% или более из этих расстояний, —
      прекрасный претендент на роль длины ключевого слова. Данная проверка
      вместе с вычислением значений <symbol>ИС</symbol> однозначно определяет
      длину ключевого слова.</para>

      <para>Предположим, нам удалось выяснить, что длина ключевого слова равна
      <symbol>k</symbol>. Тогда первоначальный шифрованный текст можно разбить
      на <symbol>k</symbol> групп <symbol>G1</symbol>, <symbol>G2</symbol>,
      ..., <symbol>Gk</symbol>, где каждая группа начинается с позиции
      <symbol>i</symbol>, <inlineequation>
          <m:math display="inline">
            <m:mrow>
              <m:mtext>1</m:mtext>

              <m:mo>≤</m:mo>

              <m:mtext>i</m:mtext>

              <m:mo>≤</m:mo>

              <m:mtext>k</m:mtext>
            </m:mrow>
          </m:math>
        </inlineequation>, и содержит каждую <symbol>k</symbol>-ю букву
      текста, начиная с <symbol>i</symbol>-й буквы. Каждая из этих
      <symbol>k</symbol> групп была зашифрована при помощи только одного
      алфавита, т. е. при помощи простой подстановки. Остается в каждой группе
      для каждой шифрованной буквы определить ее эквивалент в исходном тексте.
      Но здесь у нас имеется хорошее подспорье. Если бы был известен алфавит,
      по которому была зашифрована какая-нибудь из групп, то алфавит, по
      которому была зашифрована любая другая группа, можно было бы найти путем
      циклического сдвига уже известного алфавита на некоторое число букв. С
      другой стороны, определить исходные эквиваленты букв было бы проще, если
      бы удалось распределения числа появлений букв для различных групп
      скомбинировать в одно обобщенное распределение, поскольку, чем больше
      данных было использовано для построения какого-либо распределения, тем
      достовернее будут сделанные на его основе статистические выводы. Для
      построения такой комбинации необходимо знать относительные сдвиги между
      алфавитами, использованными для шифрования различных групп.</para>

      <para>Относительные сдвиги находятся при помощи некой модификации
      индекса совпадения. Построим для каждой группы
      <symbol>G<subscript>i</subscript></symbol> распределение числа появлений
      букв И запишем его в алфавитном порядке шифрованных букв. В табл. 24.1
      показаны распределения для сообщения, приведенного на рис. 24.1, в
      предположении, что <symbol>k</symbol>=7. Пусть
      <symbol>f<subscript>iα</subscript></symbol>-количество появлений буквы
      <symbol>α</symbol> алфавита <symbol>i</symbol>. Определим функцию</para>

      <equation>
        <m:math display="block">
          <m:mrow>
            <m:msub>
              <m:mi>R</m:mi>

              <m:mi>i, j, r</m:mi>
            </m:msub>

            <m:mo>=</m:mo>

            <m:mrow>
              <m:munderover>
                <m:mo>∑</m:mo>

                <m:mrow>
                  <m:mi>β</m:mi>

                  <m:mo>=</m:mo>

                  <m:mi>1</m:mi>
                </m:mrow>

                <m:mi>32</m:mi>
              </m:munderover>

              <m:mrow>
                <m:msub>
                  <m:mi>f</m:mi>

                  <m:mi>i, β</m:mi>
                </m:msub>

                <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                <m:msub>
                  <m:mi>f</m:mi>

                  <m:mi>j, β + r</m:mi>
                </m:msub>
              </m:mrow>
            </m:mrow>
          </m:mrow>
        </m:math>
      </equation>

      <para>Считается, что если <symbol>β+r</symbol> больше 32, то происходит
      циклический возврат к началу алфавита. Чем больше значение
      <symbol>R<subscript>i,j,r</subscript></symbol>, тем больше вероятность
      того, что алфавит для группы <symbol>j</symbol> в квадрате Виженера
      находится на <symbol>r</symbol> позиций ниже алфавита для группы
      <symbol>i</symbol>. Вычислим все значения
      <symbol>R<subscript>i,j,r</subscript></symbol> (для <symbol>j ≤
      i</symbol> их можно не вычислять благодаря свойству симметрии) и выберем
      <symbol>i</symbol> и <symbol>j</symbol>, которые дают максимальное
      значение <symbol>R<subscript>i,j,r</subscript></symbol>. Вероятно,
      группа <symbol>j</symbol> сдвинута на <symbol>r</symbol> позиций
      относительно группы <symbol>i</symbol>.</para>
    </section>
  </chapter>
</book>
